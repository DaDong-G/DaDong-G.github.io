<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大东的博客</title>
  
  <subtitle>东子的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Daong.com/"/>
  <updated>2019-12-30T08:26:50.787Z</updated>
  <id>https://Daong.com/</id>
  
  <author>
    <name>东子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言练习Rpc</title>
    <link href="https://Daong.com/2019/12/20/Rpc/"/>
    <id>https://Daong.com/2019/12/20/Rpc/</id>
    <published>2019-12-20T02:09:00.000Z</published>
    <updated>2019-12-30T08:26:50.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rpc架构"><a href="#Rpc架构" class="headerlink" title="Rpc架构"></a>Rpc架构</h2><p><img src="/2019/12/20/Rpc/rpc.jpg" alt="rpc图片"></p><p>Rpc就是从一台机器（客户端）上通过传递参数的方法远程调用另一台机器（或者另一个进程）的函数或者方法，统称服务，并且返回结果。</p><p>Rpc的流程如上图：</p><ol><li><p>Client将需要请求的方法名，参数 发送给Client Stub(客户端存根)</p></li><li><p>Client Stub将 方法名，参数进行打包，解包。具体打包方式：例如 方法名为 hello,在包的头部记录下长度，然后将Hello 进行二进制打包。</p></li><li><p>Client Stub 将信息传给Network Service</p></li><li><p>Network Service 通过Socket 进行通信</p></li><li><p>Network Service 将二进制数据传给 Server stub</p></li><li><p>Server stub 主要作用 与 Client Stub 一样，将数据进行解包，打包。</p></li><li><p>Server stub 将转换好的数据传给Server。</p></li></ol><p>首先实现一个最简单的Rpc，将Go语言中有标准包net/rpc，下面代码中没有设计client stub sever sub  以及网络通信的详细描述，RPC也希望屏蔽这些信息，开发人员只需要调用。</p><p>Server 端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//定义一个方法，必须满足RPC规则，方法只能有两个可序列化的参数,第二个参数是指针类型。</span><br><span class="line">func (h *HelloServer)Hello(request int,reply *string)error&#123;</span><br><span class="line">*reply = fmt.Sprintf(&quot;Hello 方法: %d&quot;,request)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// RegisterName 将对象类型中，所有满足RPC规则的方法进行注册。放在HelloServer下。</span><br><span class="line">err := rpc.RegisterName(&quot;HelloServer&quot;, new(HelloServer))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">//fmt.Println(err)</span><br><span class="line">log.Fatal(&quot;Rpc名称注册错误&quot;)</span><br><span class="line">//fmt.Println(&quot;Rpc名称注册错误&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listener, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(&quot;accept error;接收错误&quot;)</span><br><span class="line">//fmt.Println(&quot;Rpc名称注册错误&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">fmt.Println(&quot;开始循环接收请求&quot;)</span><br><span class="line">conn, err := listener.Accept()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cilent 端 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">// 拨号 输入协议名称，地址</span><br><span class="line">client,err := rpc.Dial(&quot;tcp&quot;,&quot;127.0.0.1:1234&quot;)</span><br><span class="line">if err != nil&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">var replay * string</span><br><span class="line">var replayGoodMethods * string</span><br><span class="line">// 定义的replay 用于接收服务端处理完的请求。Call方法用于发送请求，是同步的。</span><br><span class="line">// client.Go可以异步的发送请求。</span><br><span class="line">err = client.Call(&quot;HelloServer.Hello&quot;,123,&amp;replay)</span><br><span class="line">err = client.Call(&quot;HelloServer.Good&quot;,&quot;Client 端Good方法&quot;,&amp;replayGoodMethods)</span><br><span class="line">if err != nil&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">fmt.Println(&quot;Send remote method error&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;%#v\n&quot;, *replay)</span><br><span class="line">fmt.Printf(&quot;%#v\n&quot;, *replayGoodMethods)</span><br><span class="line">err = client.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础的Client 与Server已经完成，在RPC开发中开发人员一般有三种角色，服务器RPC方法的开发人员，客户端调用RPC的人员，指定RPC客户端与服务器协议的人员。</p><p>接下来讲HelloServer服务进行重构，进行接口封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const HelloServerName  = &quot;HelloService&quot;</span><br><span class="line"></span><br><span class="line">// 定义封装一个接口</span><br><span class="line">type HelloServerInterface interface &#123;</span><br><span class="line">Hello(request int, reply *string) error</span><br><span class="line">Good(request string, reply *string) error</span><br><span class="line">&#125;</span><br><span class="line">// 定义一个类</span><br><span class="line">type struct HelloService&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 接口方法</span><br><span class="line">func RegisterHelloService(svc HelloServerInterface)&#123;</span><br><span class="line">return rpc.RegisterName(HelloServerName,svc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//必须满足RPC规则，方法只能有两个可序列化的参数,第二个参数是指针类型。</span><br><span class="line">func (h *HelloServer)Hello(request int,reply *string)error&#123;</span><br><span class="line">*reply = fmt.Sprintf(&quot;Hello 方法: %d&quot;,request)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *HelloServer)Good(request string,reply *string)error&#123;</span><br><span class="line">*reply = &quot;Good 方法:&quot; + request</span><br><span class="line">return nil</span><br></pre></td></tr></table></figure><p>可以对Client端也进行一次封装,这样可以避免出现参数类型不匹配等低级错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const HelloServerName  = &quot;HelloService&quot;</span><br><span class="line">type HelloServerClient struct &#123;</span><br><span class="line">Client *rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DialHelloService(network,address string)(*HelloServerClient,error)&#123;</span><br><span class="line">c , err := rpc.Dial(network,address)</span><br><span class="line">if err != nil&#123;</span><br><span class="line">return nil,err</span><br><span class="line">&#125;</span><br><span class="line">return &amp;HelloServerClient&#123;Client:c&#125;,nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p HelloServerClient)Hello(request int,reply *string)error&#123;</span><br><span class="line">return p.Client.Call(HelloServerName+&quot;.Hello&quot;, request, reply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p HelloServerClient)Good(request string,reply *string)error&#123;</span><br><span class="line">return p.Client.Call(HelloServerName+&quot;.Good&quot;, request, reply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">client , err := DialHelloService(&quot;tcp&quot;,&quot;127.0.0.1:1234&quot;)</span><br><span class="line">//client,err := rpc.Dial(&quot;tcp&quot;,&quot;127.0.0.1:1234&quot;)封装在DialHelloService方法</span><br><span class="line">if err != nil&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">var replay string</span><br><span class="line">var replayGoodMethods string</span><br><span class="line">err = (*client).Hello(1213, &amp;replay)</span><br><span class="line">err = (*client).Good(&quot;Good方法&quot;,&amp;replayGoodMethods)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%#v\n&quot;, replay)</span><br><span class="line">fmt.Printf(&quot;%#v,\n&quot;, replayGoodMethods)</span><br><span class="line">_ = client.Client.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Rpc架构&quot;&gt;&lt;a href=&quot;#Rpc架构&quot; class=&quot;headerlink&quot; title=&quot;Rpc架构&quot;&gt;&lt;/a&gt;Rpc架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/12/20/Rpc/rpc.jpg&quot; alt=&quot;rpc图片&quot;&gt;&lt;/p&gt;
&lt;p&gt;Rpc
      
    
    </summary>
    
      <category term="Go语言" scheme="https://Daong.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Rpc" scheme="https://Daong.com/tags/Rpc/"/>
    
  </entry>
  
  <entry>
    <title>Go语言通过Context控制goroutine的退出</title>
    <link href="https://Daong.com/2019/11/28/Context/"/>
    <id>https://Daong.com/2019/11/28/Context/</id>
    <published>2019-11-28T02:09:00.000Z</published>
    <updated>2019-12-30T07:56:27.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-通过-Context控制goroutine-的退出"><a href="#Go-通过-Context控制goroutine-的退出" class="headerlink" title="Go 通过 Context控制goroutine 的退出"></a>Go 通过 Context控制goroutine 的退出</h2><p>下面的程序会无线循环，直到4秒后，主进程退出。那么如何优雅的控制子goroutine退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func f ()&#123;</span><br><span class="line">go g()</span><br><span class="line">time.Sleep(time.Second * 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func g ()&#123;</span><br><span class="line">for  &#123;</span><br><span class="line">fmt.Println(&quot;急啊急啊急啊&quot;)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">&#125;</span><br><span class="line">//如何通知子goroutine退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用chan进行改进，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">var ch = make(chan bool)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func f ()&#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go g()</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">ch &lt;- true</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func g ()&#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">LOOP:</span><br><span class="line">for  &#123;</span><br><span class="line">fmt.Println(&quot;急啊急啊急啊&quot;)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;- ch: //当接收到一个chan跳出for循环，</span><br><span class="line">break LOOP</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//如何通知子goroutine退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Context版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;context&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func f ()&#123;</span><br><span class="line">// 开启一个context,context.Background()为父节点。</span><br><span class="line">// ctx 是个接口，ctx,Done()会返回一个chanel</span><br><span class="line">// cancel是一个函数类型 用于关闭</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">wg.Add(1)</span><br><span class="line">go g(ctx)</span><br><span class="line">time.Sleep(time.Second * 4)</span><br><span class="line">//ch &lt;- true</span><br><span class="line">cancel()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func g (ctx context.Context)&#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">LOOP:</span><br><span class="line">for  &#123;</span><br><span class="line">fmt.Println(&quot;等待退出&quot;)</span><br><span class="line">time.Sleep(time.Second * 2)</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;- ctx.Done(): //ctx.Done() 会返回一个chanel</span><br><span class="line">break LOOP</span><br><span class="line">default:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//如何通知子goroutine退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>context.Context</code>是一个接口，该接口定义了四个需要实现的方法。具体签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Deadline 设置具体时间结束子进程</p><p>Done  当决定子线程结束时，context.Done()可以得到一个空的chan</p><p>Err  返回错误</p><p>Value 方法会从<code>Context</code>中返回键对应的值，对于同一个上下文来说，多次调用<code>Value</code> 并传入相同的<code>Key</code>会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</p><h4 id="一般以context-Background-实现一个跟节点，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。"><a href="#一般以context-Background-实现一个跟节点，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。" class="headerlink" title="一般以context.Background()实现一个跟节点，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。"></a>一般以context.Background()实现一个跟节点，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 返回的cancel 方法可以用于结束子goroutine，子goroutine中的context.DOne()会接收一个chan struct&#123;&#125;。</span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line"></span><br><span class="line">// 定一个具体时间，结束子goroutine，也可以手动结束，官方建议所有的最好手动关闭。</span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) </span><br><span class="line"></span><br><span class="line">// 定多少事件后，结束子goroutine，也可以手动结束，官方建议所有的最好手动关闭。</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) </span><br><span class="line"></span><br><span class="line">// 用于传递一个值给子goroutine</span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go-通过-Context控制goroutine-的退出&quot;&gt;&lt;a href=&quot;#Go-通过-Context控制goroutine-的退出&quot; class=&quot;headerlink&quot; title=&quot;Go 通过 Context控制goroutine 的退出&quot;&gt;&lt;/a&gt;Go
      
    
    </summary>
    
      <category term="Go语言" scheme="https://Daong.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="并发编程" scheme="https://Daong.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中无缓冲通道实现并发池</title>
    <link href="https://Daong.com/2019/11/11/Go_Work/"/>
    <id>https://Daong.com/2019/11/11/Go_Work/</id>
    <published>2019-11-11T02:09:00.000Z</published>
    <updated>2019-12-29T10:27:19.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-语言并发，使用无缓冲通道构建并发池。"><a href="#Go-语言并发，使用无缓冲通道构建并发池。" class="headerlink" title="Go 语言并发，使用无缓冲通道构建并发池。"></a>Go 语言并发，使用无缓冲通道构建并发池。</h2><p>首先构建一个并发池，有两个字段一个是work  通道类型，一个是sync.WaitGroup。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Pool struct &#123;   </span><br><span class="line">work chan Worker   </span><br><span class="line">wg sync.WaitGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为工作并发池 提供一个接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Worker interface &#123;</span><br><span class="line">Task()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着创建一个新的工作池，使用工厂函数来创建,返回值为Pool</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func New(maxGoroutines int) *Pool  &#123;</span><br><span class="line">p := Pool&#123;</span><br><span class="line">work : make(chan Worker),</span><br><span class="line">&#125;</span><br><span class="line">p.wg.Add(maxGorotuine) //往并发池添加并发的数量</span><br><span class="line">for i:= 0 ; i &lt; maxGoroutines; i ++&#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">for w := range p.work&#123;   // 这里会发生阻塞，在创建的时候，异步阻塞，返回一个池</span><br><span class="line">w.Task()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">p.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">return &amp;p</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将工作提交到工作池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (p *Pool)Run(w Worker)  &#123;</span><br><span class="line">p.work &lt;- w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭工作池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (p *Pool)Shutdown()&#123;   </span><br><span class="line">close(p.work)   </span><br><span class="line">p.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是对上面的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var names = []string&#123;</span><br><span class="line">&quot;steve&quot;,</span><br><span class="line">&quot;bob&quot;,</span><br><span class="line">&quot;mary&quot;,</span><br><span class="line">&quot;therese&quot;,</span><br><span class="line">&quot;jason&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type namePrinter struct &#123;</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *namePrinter)Task()  &#123;</span><br><span class="line">fmt.Println(m.name)</span><br><span class="line">time.Sleep(time.Second )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">p := New(10) //创建10个并发池子</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">wg.Add(10 * len(names))</span><br><span class="line"></span><br><span class="line">// time.Sleep(3 * time.Second)</span><br><span class="line"></span><br><span class="line">for i :=0 ; i &lt; 10 ; i ++&#123;</span><br><span class="line">for _ , name := range names&#123;</span><br><span class="line">np := namePrinter&#123;</span><br><span class="line">name : name,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">p.Run(&amp;np)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">p.Shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go-语言并发，使用无缓冲通道构建并发池。&quot;&gt;&lt;a href=&quot;#Go-语言并发，使用无缓冲通道构建并发池。&quot; class=&quot;headerlink&quot; title=&quot;Go 语言并发，使用无缓冲通道构建并发池。&quot;&gt;&lt;/a&gt;Go 语言并发，使用无缓冲通道构建并发池。&lt;/
      
    
    </summary>
    
      <category term="Go语言" scheme="https://Daong.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="并发编程" scheme="https://Daong.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go语言中基本的日志格式</title>
    <link href="https://Daong.com/2019/10/15/Go%E6%97%A5%E5%BF%97%E5%AE%9A%E5%88%B6/"/>
    <id>https://Daong.com/2019/10/15/Go日志定制/</id>
    <published>2019-10-15T02:09:00.000Z</published>
    <updated>2019-12-29T10:26:30.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言日志的基本格式"><a href="#Go语言日志的基本格式" class="headerlink" title="Go语言日志的基本格式"></a>Go语言日志的基本格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;io&quot;</span><br><span class="line">&quot;io/ioutil&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">Trace.Println(&quot;这是Trac&quot;)</span><br><span class="line">Info.Println(&quot;这是Info&quot;)</span><br><span class="line">Warning.Println(&quot;这是Warning&quot;)</span><br><span class="line">Error.Println(&quot;这是Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">Trace *log.Logger // 记录所有的日志</span><br><span class="line">Info  *log.Logger // 记录重要的信息</span><br><span class="line">Warning *log.Logger // 需要注意的信息</span><br><span class="line">Error    *log.Logger // 记录非常严重信息</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">file,err := os.OpenFile(&quot;./errors.txt&quot;,os.O_CREATE,0666)</span><br><span class="line">if err!= nil&#123;</span><br><span class="line">log.Fatalln(&quot;Failed to open error log&quot;)</span><br><span class="line">&#125;</span><br><span class="line">Trace = log.New(ioutil.Discard,&quot;Trace:&quot;,log.Ldate | log.Ltime | log.Lshortfile)  //ioutil.Discard 不输出，不写入，可以用于占位</span><br><span class="line">Info = log.New(os.Stdout,&quot;Info:&quot;,log.Ldate | log.Ltime | log.Lshortfile) //os.Stdout  不记录日志仅仅作为标准输出</span><br><span class="line">Warning = log.New(file,&quot;Warning:&quot;,log.Ldate | log.Ltime | log.Lshortfile) // file  会将日志写入file,并输出</span><br><span class="line">Error = log.New(io.MultiWriter(file,os.Stdin),&quot;Error:&quot;,log.Ldate | log.Ltime | log.Lshortfile) //写入，不输出，可以更改os.std。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go语言日志的基本格式&quot;&gt;&lt;a href=&quot;#Go语言日志的基本格式&quot; class=&quot;headerlink&quot; title=&quot;Go语言日志的基本格式&quot;&gt;&lt;/a&gt;Go语言日志的基本格式&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="Go语言" scheme="https://Daong.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="日志" scheme="https://Daong.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库查询优化</title>
    <link href="https://Daong.com/2019/09/21/Mysql_optimization/"/>
    <id>https://Daong.com/2019/09/21/Mysql_optimization/</id>
    <published>2019-09-21T02:09:40.000Z</published>
    <updated>2019-10-02T03:19:31.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何获得有性能问题的sql"><a href="#如何获得有性能问题的sql" class="headerlink" title="如何获得有性能问题的sql"></a>如何获得有性能问题的sql</h3><p><strong>慢查询日志：</strong></p><p>​    MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p><p><strong>MySQL 慢查询的相关参数解释：</strong></p><p>slow_query_log    ：是否开启慢查询日志，1表示开启，0表示关闭。<br>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。<br>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。<br>log_output：日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</p><p><strong>慢查询日志配置</strong></p><p>​        默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables  like &apos;%slow_query_log%&apos;;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                           |</span><br><span class="line">| slow_query_log_file | /home/WDPM/MysqlData/mysql/DB-Server-slow.log |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; set global slow_query_log=1;</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; show variables like &apos;%slow_query_log%&apos;;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log      | ON                                            |</span><br><span class="line">| slow_query_log_file | /home/WDPM/MysqlData/mysql/DB-Server-slow.log |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure><p><strong>慢查询日志相关分析工具mysqldumpslow</strong><br>​        -s, 是表示按照何种方式排序，</p><blockquote><p>c: 访问计数</p><p>l: 锁定时间</p><p>r: 返回记录</p><p>t: 查询时间</p><p>al:平均锁定时间</p><p>ar:平均返回记录数</p><p>at:平均查询时间</p></blockquote><p>-t, 是top n的意思，即为返回前面多少条的数据；<br>-g, 后边可以写一个正则匹配模式，大小写不敏感的；<br>比如<br>得到返回记录集最多的10个SQL。<br>mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log<br>得到访问次数最多的10个SQL<br>mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log<br>得到按照时间排序的前10条里面含有左连接的查询语句。<br>mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log<br>另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。<br>mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more<br>实时获取有问题的sql</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何获得有性能问题的sql&quot;&gt;&lt;a href=&quot;#如何获得有性能问题的sql&quot; class=&quot;headerlink&quot; title=&quot;如何获得有性能问题的sql&quot;&gt;&lt;/a&gt;如何获得有性能问题的sql&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;慢查询日志：&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
      <category term="数据库" scheme="https://Daong.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="https://Daong.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库的事务</title>
    <link href="https://Daong.com/2019/09/14/Mysql/"/>
    <id>https://Daong.com/2019/09/14/Mysql/</id>
    <published>2019-09-14T02:09:40.000Z</published>
    <updated>2019-09-14T07:49:41.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mysql事务四个特性"><a href="#Mysql事务四个特性" class="headerlink" title="Mysql事务四个特性"></a>Mysql事务四个特性</h3><ul><li>一致性</li><li>原子性</li><li>隔离性</li><li>持久性</li></ul><h4 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h4><p>整个事务中所有的操作要么全部提交成功，要么全部失败回滚。</p><h4 id="一致性："><a href="#一致性：" class="headerlink" title="一致性："></a>一致性：</h4><p>数据库中的数据从一种状态转到另外一种状态，数据的完整性没有被破坏。</p><h4 id="隔离性："><a href="#隔离性：" class="headerlink" title="隔离性："></a>隔离性：</h4><ol><li><p>未提交读(Read-uncommited)：<br>(begin)开启一个事务(A)，对数据进行了更改，并未commit。此时另外一个事务(B)，可以读取到事务A 修改的数据。所以，如果事务A突然崩溃回滚，那么事务(B)读取的数据是不正确的。 未提交读也称为脏读。</p></li><li><p>读取-已提交(Read-committed):<br>例1： (begin)开启一个事务(A),对数据(money:200 )进行了修改(money:2000)，并未commit，此时另外一个事务(B)无法读取到修改后的数据，如果此时B也对数据进行修改(money:200)修改为(money:2000) UPDATE test_shiwu SET money = 300 WHERE money = 2000;, 那么将会阻塞，直到事务A commit 才能解除阻塞，解除后无法修改，因为无法找money = 2000的数据，此时money已经被A修改成了200。<br>例2：(begin)开启一个事务(A), (begin)开启一个事务(B),A事务修改了数据，并且进行了提交，此时B事务对数据进行查询，可以读取到A修改后的数据。</p></li><li><p>可重复读取(RepeaTable-Read):<br>(begin)开启一个事务(A), (begin)开启一个事务(B),A事务修改了数据，并且进行了提交，此时B事务对数据进行查询，查到的数据依然是修改前的数据，只有B事务commit后，才能读取到A修改后的数据。</p></li><li><p>串行化(serializable):</p><p> (begin)开启一个事务(A), (begin)开启一个事务(B)，由于A事务先开启，所以此时B操作数据库任何信息都会发生阻塞，直到A commit 才能解除阻塞。    </p></li></ol><h4 id="持久性："><a href="#持久性：" class="headerlink" title="持久性："></a>持久性：</h4><p>事务一旦提交，其更改是永久性的，即使数据库系统崩溃也能恢复。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mysql事务四个特性&quot;&gt;&lt;a href=&quot;#Mysql事务四个特性&quot; class=&quot;headerlink&quot; title=&quot;Mysql事务四个特性&quot;&gt;&lt;/a&gt;Mysql事务四个特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一致性&lt;/li&gt;
&lt;li&gt;原子性&lt;/li&gt;
&lt;li&gt;隔离
      
    
    </summary>
    
      <category term="数据库" scheme="https://Daong.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="https://Daong.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Docker之Docker-compose</title>
    <link href="https://Daong.com/2019/09/14/docker_compose/"/>
    <id>https://Daong.com/2019/09/14/docker_compose/</id>
    <published>2019-09-14T02:09:00.000Z</published>
    <updated>2019-09-08T07:15:41.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Docker-compose"><a href="#什么是Docker-compose" class="headerlink" title="什么是Docker-compose"></a>什么是Docker-compose</h3><p>docker-compose技术，就是通过一个 <strong>.yml</strong> 配置文件，将所有的容器的部署方法、文件映射、容器连接等等一系列的配置写在一个配置文件里，最后只需要执行docker-compose up命令就会像执行脚本一样的去一个个安装容器并自动部署他们，极大的便利了复杂服务的部署。</p><h3 id="Docker-compose-撰写案例"><a href="#Docker-compose-撰写案例" class="headerlink" title="Docker-compose 撰写案例"></a>Docker-compose 撰写案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.6&quot;   # 代表语言版本</span><br><span class="line">services: # 代表要启动哪几个容器</span><br><span class="line">  flask-web: # 自己起一个名字</span><br><span class="line">    build: .  # 如果使用dockerfile就是用build .,如果是已经有的镜像，使用用images</span><br><span class="line">    ports: # 需要映射的端口 很多种写法，可以查</span><br><span class="line">      - &quot;5000:5000&quot;</span><br><span class="line">    container_name: flask-web # 容器起个名字</span><br><span class="line">    networks: # 使用的网络</span><br><span class="line">      - web</span><br><span class="line">  redis: #  容器项目 名字</span><br><span class="line">    image: redis  # 使用的镜像 redis </span><br><span class="line">    container_name: redis # 容器名称</span><br><span class="line">    networks:</span><br><span class="line">      - web</span><br><span class="line">    volumes: # 容器挂载的地址，遵循下面的volumes写，可以保证即便删除，下次数据不会丢失，都存在了数据卷里面。  </span><br><span class="line">      - redis-dat:/data # 将数据卷挂载到容器/data 文件  </span><br><span class="line">networks: # 定义网络类型</span><br><span class="line">  web:</span><br><span class="line">    driver: &quot;bridge&quot;  # 设置网络类型</span><br><span class="line">volumes: # 容器挂载地址</span><br><span class="line">  redis-dat:  # 代表的是 name</span><br><span class="line">    driver: &quot;local&quot;    # 代表的是DRIVERname</span><br></pre></td></tr></table></figure><h3 id="Docker-compose-命令"><a href="#Docker-compose-命令" class="headerlink" title="Docker-compose 命令"></a>Docker-compose 命令</h3><p>docker-compose up：该命令可以自动完成包括构建镜像，(重新)创建服务，启动服务，并关联服务相关容器的一系列操作。 -d 代表后台运行</p><p>docker-compose pause ：暂停服务<br>docker-compose unpause  ：恢复被暂停的服务</p><p>dokcer-compose ps ： 此命令与docker ps不同作用，此命令会显示停止后的容器（状态为Exited），只针对某个项目。</p><p>docker-compose restart [service_name]：重启某个项目，只有正在运行的服务可以使用重启命令，停止的服务是不可以重启</p><p>docker-compose start : 启动运行某个服务的所有容器<br>docker-compose stop : 停止运行某个服务的所有容器</p><p>docker-compose logs [service_name] : 显示service的日志信息</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Docker-compose&quot;&gt;&lt;a href=&quot;#什么是Docker-compose&quot; class=&quot;headerlink&quot; title=&quot;什么是Docker-compose&quot;&gt;&lt;/a&gt;什么是Docker-compose&lt;/h3&gt;&lt;p&gt;docker-com
      
    
    </summary>
    
      <category term="虚拟化" scheme="https://Daong.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://Daong.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之Dockerfile</title>
    <link href="https://Daong.com/2019/09/11/DockerFile/"/>
    <id>https://Daong.com/2019/09/11/DockerFile/</id>
    <published>2019-09-11T02:09:00.000Z</published>
    <updated>2019-09-08T06:44:01.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Dockerfile："><a href="#什么是Dockerfile：" class="headerlink" title="什么是Dockerfile："></a>什么是Dockerfile：</h3><p>Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取<code>Dockerfile</code>中的指令自动生成映像。</p><p><code>docker build</code>命令用于从Dockerfile构建映像。可以在<code>docker build</code>命令中使用<code>-f</code>标志指向文件系统中任何位置的Dockerfile。</p><h3 id="Dockerfile的撰写示例"><a href="#Dockerfile的撰写示例" class="headerlink" title="Dockerfile的撰写示例"></a>Dockerfile的撰写示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 搭建一个基于flask 的web项目</span><br><span class="line">FROM python:3.6-alpine</span><br><span class="line">LABEL Description=&quot;本镜像用于启动建议的基于flask的web程序&quot; Author=&quot;Itcast&quot; Version=&quot;1.0&quot;</span><br><span class="line"># 将代码保存到镜像</span><br><span class="line">COPY ./code /flask-code</span><br><span class="line"># 运行目录至code 目录下</span><br><span class="line">WORKDIR /flask-code</span><br><span class="line"># 执行 安装 项目需要的依赖</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"># 执行代码</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><p>docker build /home/dockerfile-dir/ -t test-image:v1.0     -t的代表命名  </p><p>执行上述命令，会执行/home/dockerfile-dir/  下面的Dockerfile文件</p><h3 id="Dockerfile文档中的命令："><a href="#Dockerfile文档中的命令：" class="headerlink" title="Dockerfile文档中的命令："></a>Dockerfile文档中的命令：</h3><ol><li><p>FROM   //指定基于哪个基础镜像格式 FROM <p_w_picpath> 或者  FROM <p_w_picpath>:<tag>，  比如</tag></p_w_picpath></p_w_picpath></p><p>FROM centos</p><p>FROM centos:latest</p></li></ol><ol start="2"><li><p>MAINTAINER  //指定作者信息</p><p>格式  MAINTAIN <name> ，比如</name></p><p>MAINTAINER  aming  <a href="mailto:aming@aminglinux.com" target="_blank" rel="noopener">aming@aminglinux.com</a></p></li></ol><ol start="3"><li><p>RUN   //镜像操作指令</p><p>格式为 RUN <command>  或者 RUN [“executable”, “param1”, “param2”]，比如</p><p>RUN  yum install  httpdRUN [“/bin/bash”, “-c”, “echo hello”]</p></li></ol><ol start="4"><li><p>CMD  // 三种格式：CMD [“executable”, “param1”, “param2”]CMD command param1 param2</p><p>CMD [“param1”, “param2”]</p><p>RUN和CMD看起来挺像，但是CMD用来指定容器启动时用到的命令，只能有一条。比如</p><p>CMD [“/bin/bash”, “/usr/local/nginx/sbin/nginx”, “-c”, “/usr/local/nginx/conf/nginx.conf”]</p></li></ol><ol start="5"><li><p>EXPOSE  格式为 EXPOSE <port> [<port>…] , 比如</port></port></p><p>EXPOSE 22 80 8443这个用来指定要映射出去的端口，比如容器内部我们启动了sshd和nginx，所以我们需要把22和80端口暴漏出去。这个需要配合-P（大写）来工作，也就是说在启动容器时，需要加上-P，让它自动分配。如果想指定具体的端口，也可以使用-p（小写）来指定。</p></li></ol><ol start="6"><li><p>ENV  格式 ENV  <key> <value>, 比如  </value></key></p><p>ENV PATH /usr/local/mysql/bin:$PATH它主要是为后续的RUN指令提供一个环境变量，我们也可以定义一些自定义的变量</p><p>ENV MYSQL_version 5.6</p></li></ol><ol start="7"><li><p>ADD  </p><p>格式 add <src> <dest></dest></src></p><p>将本地的一个文件或目录拷贝到容器的某个目录里。 其中src为Dockerfile所在目录的相对路径，它也可以是一个url。比如</p><p>ADD &lt;conf/vhosts&gt; &lt;/usr/local/nginx/conf&gt;</p></li></ol><ol start="8"><li><p>COPY  格式同add</p><p>使用方法和add一样，不同的是，它不支持url</p></li></ol><ol start="9"><li><p>ENTRYPOINT  </p><p>格式类似CMD</p><p>容器启动时要执行的命令，它和CMD很像，也是只有一条生效，如果写多个只有最后一条有效。和CMD不同是：CMD 是可以被 docker run 指令覆盖的，而ENTRYPOINT不能覆盖。比如，容器名字为aming</p><p>我们在Dockerfile中指定如下CMD：</p><p>CMD [“/bin/echo”, “test ”]</p><p>启动容器的命令是  docker run aming 这样会输出 test</p><p>假如启动容器的命令是 docker run -it aming  /bin/bash  什么都不会输出</p><p>ENTRYPOINT不会被覆盖，而且会比CMD或者docker run指定的命令要靠前执行</p><p>ENTRYPOINT [“echo”, “test”]</p><p>docker run -it aming  123</p><p>则会输入 test  123 ，这相当于要执行命令  echo test  123 </p></li></ol><ol start="10"><li><p>VOLUME </p><p>格式  VOLUME [“/data”]</p><p>创建一个可以从本地主机或其他容器挂载的挂载点。</p></li></ol><ol start="11"><li><p>USER  </p><p>格式 USER daemon</p><p>指定运行容器的用户</p></li></ol><ol start="12"><li><p>WORKDIR  </p><p>格式 WORKDIR  /path/to/workdir</p><p>为后续的RUN、CMD或者ENTRYPOINT指定工作目录</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Dockerfile：&quot;&gt;&lt;a href=&quot;#什么是Dockerfile：&quot; class=&quot;headerlink&quot; title=&quot;什么是Dockerfile：&quot;&gt;&lt;/a&gt;什么是Dockerfile：&lt;/h3&gt;&lt;p&gt;Dockerfile是一个包含用于组合映像的
      
    
    </summary>
    
      <category term="虚拟化" scheme="https://Daong.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://Daong.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础之数据卷</title>
    <link href="https://Daong.com/2019/09/08/Docker_data_volume/"/>
    <id>https://Daong.com/2019/09/08/Docker_data_volume/</id>
    <published>2019-09-08T02:09:00.000Z</published>
    <updated>2019-09-08T05:10:26.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据卷挂载的三种方式"><a href="#数据卷挂载的三种方式" class="headerlink" title="数据卷挂载的三种方式"></a>数据卷挂载的三种方式</h3><ul><li>bind mounts：将宿主机上的一个文件或目录被挂载到容器上。</li><li>volumes: 由docker创建和管理，使用docker volume 命令管理，相当于是对bind mounts 的封装。</li><li>tmpfs mounts: 一种基于内存的的临时文件系统，该方法不会将数据写入磁盘，写在内存中。</li></ul><h3 id="volume-相关命令："><a href="#volume-相关命令：" class="headerlink" title="volume 相关命令："></a>volume 相关命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker volume create [name] 创建数据卷</span><br><span class="line"></span><br><span class="line">docker volume inspect [name] 查看数据卷详情</span><br><span class="line"></span><br><span class="line">docker volume prune 删除未使用的数据卷</span><br><span class="line"></span><br><span class="line">docker volume ls 查看所有数据卷</span><br><span class="line"></span><br><span class="line">docker rm volume</span><br></pre></td></tr></table></figure><h3 id="bind-mounts："><a href="#bind-mounts：" class="headerlink" title="bind mounts："></a>bind mounts：</h3><ol><li><p>方法一： -v 参数，跟文件路径</p><p>​    docker run -dit  -v /volume:/data –name centos_test centos </p><p>​    将/volume 挂载到 容器 /data ,如果本地的文件不存在，会自动创建</p></li><li><p>方法二：–mount type=bind,src=本地路径,dst=容器路径  centos </p><p>​    docker run -dit –mount type=bind,src=/volume,dst=/root/v –name centos_test centos</p><p>​    将/volume 挂载到 容器 /root/v,如果本地的文件不存在，报错</p></li></ol><h3 id="volumes："><a href="#volumes：" class="headerlink" title="volumes："></a>volumes：</h3><ol><li><p>方法一： -v 参数  跟数据卷的名称</p><p>​    docker run -dit -v volume-test:/root/a centos</p><p>​    docker 会创建出来一个volume数据卷挂载到容器的 root/a路径</p></li><li><p>方法二：–mount type=volume,src=本地路径,dst=容器路径  centos </p><p>​    docker run -dit –mount type=volume,src=volume-test(数据卷名称),dst=/root/v   centos</p><p>​    文件不存在不会报错，都会自动创建</p></li></ol><h3 id="tmpfs-："><a href="#tmpfs-：" class="headerlink" title="tmpfs ："></a>tmpfs ：</h3><p>​        –mount type=tmpfs,dst=容器路径  centos。只有一种方法</p><h3 id="共享其他容器的数据卷："><a href="#共享其他容器的数据卷：" class="headerlink" title="共享其他容器的数据卷："></a>共享其他容器的数据卷：</h3><p>​            docker run -dti –volumes-from 容器名  镜像名 </p><h3 id="数据卷使用注意："><a href="#数据卷使用注意：" class="headerlink" title="数据卷使用注意："></a>数据卷使用注意：</h3><p>​            <strong>如果挂载一个空的数据卷到容器中的一个非空目录中，那么这个目录下的文件会被复制到数据卷中。<br>​            如果挂载一个非空的数据卷到容器中的一个目录中，那么容器中的目录中会显示数据卷中的数据。如果原            来容器中的目录中有数据，那么这些原始数据会被隐藏掉。</strong></p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据卷挂载的三种方式&quot;&gt;&lt;a href=&quot;#数据卷挂载的三种方式&quot; class=&quot;headerlink&quot; title=&quot;数据卷挂载的三种方式&quot;&gt;&lt;/a&gt;数据卷挂载的三种方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;bind mounts：将宿主机上的一个文件或目录被挂载到容器上
      
    
    </summary>
    
      <category term="虚拟化" scheme="https://Daong.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://Daong.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础之网络</title>
    <link href="https://Daong.com/2019/09/07/Docker_network/"/>
    <id>https://Daong.com/2019/09/07/Docker_network/</id>
    <published>2019-09-07T06:40:40.000Z</published>
    <updated>2019-09-07T09:17:37.534Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><p>容器的网络默认与宿主机，其他容器都是相互隔离的。</p><p><strong>查看docker已经创建的网络对象</strong>： docker network ls </p><p><strong>查看网络详情</strong>：docker network inspect 网络名/id</p><p><strong>创建网络</strong>：docker create -d bridge  name  -d 默认为bridge 。注意：host 网络与 null 网络只能存在一个。 </p><p><strong>删除网络</strong>：docker network rm 网络名/id</p><p><strong>使用网络</strong>：docker run  –network host -dti –name 容器名 镜像名</p><p><strong>Docker网络类型</strong>：</p><ol><li><p>bridage</p><ol><li><p>宿主机需要有单独的bridage网卡，如docker 默认创建的docker0</p></li><li><p>外部无法直接访问容器，需要建立端口映射</p></li><li><p>每创建一个bridage网络，都会自动在宿主机上创建一个veth的网络。</p></li><li><p>每一个容器都有单独的ip。</p></li><li><p>容器直接无法直接通信，需要借助veth –&gt; docker0 这样进行通信。</p></li><li><p>宿主机上的veth 与 docker容器里面的 etho 是网络设备对。</p></li><li><p>bridage 网络的端口映射,将宿主机上面的某一端口，映射到容器的某一个端口。</p></li></ol></li></ol>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将镜像中暴漏出来的端口，全部随机映射到宿主机:</span><br><span class="line">docker run -dti --name test_redis -P redis </span><br><span class="line">0.0.0.0:32768-&gt;6379/tcp</span><br><span class="line">镜像只有暴露了端口，才能使用。</span><br></pre></td></tr></table></figure>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -dti --name test_redis -p 127.0.0.1:8000:6379 redis(本地ip 127.0.0.1,8000端口，映射到容器的6379端口)</span><br><span class="line">docker run -dti --name test_redis -p :8000:6379 redis  (本地8000端口映射，任意ip访问)</span><br><span class="line">docker run -dti --name test_redis -p ::6379 redis  (本地随机端口映射，任意ip访问)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Host网络</p><ol><li>容器完全共享宿主机的网络，没有任何网络隔离，宿主机的网络就是容器的网络</li><li>容器、宿主机上所有的端口不能重复，即端口必须唯一</li><li>外部可以直接访问容器，无需端口映射</li><li>容器的ip就是宿主机的ip   </li></ol></li><li><p>none 网络  </p><ol><li>容器上没有网络，也没有任何网络设备</li><li>如果需要网络，需要用户自行安装与配置</li><li>该模式适合需要高度制定网络的用户使用</li></ol></li><li><p>Overlay 网络</p><ol><li>也称覆盖网络，主要用于实现跨主机容器间的通讯。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Docker网络&quot;&gt;&lt;a href=&quot;#Docker网络&quot; class=&quot;headerlink&quot; title=&quot;Docker网络&quot;&gt;&lt;/a&gt;Docker网络&lt;/h3&gt;&lt;p&gt;容器的网络默认与宿主机，其他容器都是相互隔离的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看dock
      
    
    </summary>
    
      <category term="虚拟化" scheme="https://Daong.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://Daong.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础命令</title>
    <link href="https://Daong.com/2019/08/31/Docker_basic/"/>
    <id>https://Daong.com/2019/08/31/Docker_basic/</id>
    <published>2019-08-31T03:40:40.000Z</published>
    <updated>2019-10-09T01:34:55.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker基础命令总结"><a href="#Docker基础命令总结" class="headerlink" title="Docker基础命令总结"></a>Docker基础命令总结</h3><p><strong>搜索镜像</strong>: docker search &lt;image名称&gt;<br>可以列出仓库中所有的docker镜像，  isoffic代表是否官方</p><p><strong>查看当前镜像</strong>: docker images / docker image ls             -a 显示所有镜像<br>两者相等。可以列出自己本地所有的镜像。如果查看镜像是否相同，只需要看 IMAGE ID  是否相同  </p><p><strong>下载镜像</strong>: docker pull  Name[:版本号]<br>下载的镜像默认latest 最新版本</p><p><strong>删除镜像</strong>：docker -rmi name[:版本号]  或者  Imageid</p><p><strong>查看镜像/容器详细信息</strong>：docker inspect  镜像名/容器名  （ID也可以）</p><p><strong>查看容器</strong>： docker ps （查看已经启动的） -a （查看所有的容器）</p><p><strong>容器重命名</strong>：docker rename  容器名</p><p><strong>创建并启动程序</strong>：<br>docker run – name  容器名称    镜像名称    [命令]    相当于 docker create + docker start           前台模式<br>docker run -d – name  容器名称    镜像名称    [命令]    相当于 docker create + docker start           后台模式 </p><p><strong>启动容器参数详解</strong>：-d 参数后台运行 ，-t  容器启动是否进入终端，-i 容器启动是否提供输出功能 (例:如果没有-i,输入ls ,不会打印任何内容) 。建议自己尝试执行docker run -i / docker -t 查看区别。</p><p><strong>容器暂停</strong>：  docker pause / unpause </p><p><strong>重启容器</strong>：docker restart  容器名/容器id   新名字</p><p><strong>查看容器日志</strong>：docker log  容器名</p><p><strong>运行时操作</strong>：<br>docker attach [OPTIONS] CONTAINER    退出时，容器就关闭了  进入主进程<br>docker exec -it  container  命令     退出时 不会关闭容器  进入子进程，子进程不会进入log日志</p><p><strong>停止容器</strong>：docker kill -9 直接杀死容器，docker stop  容器名  -t  2(默认10秒，-t可以设置停止时间)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Docker基础命令总结&quot;&gt;&lt;a href=&quot;#Docker基础命令总结&quot; class=&quot;headerlink&quot; title=&quot;Docker基础命令总结&quot;&gt;&lt;/a&gt;Docker基础命令总结&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;搜索镜像&lt;/strong&gt;: docker 
      
    
    </summary>
    
      <category term="虚拟化" scheme="https://Daong.com/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://Daong.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>耗时1天，搞定hexo。</title>
    <link href="https://Daong.com/2019/08/25/first_blog/"/>
    <id>https://Daong.com/2019/08/25/first_blog/</id>
    <published>2019-08-25T03:40:40.000Z</published>
    <updated>2019-09-07T06:34:25.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="详解Hexo，快速上手，从使用到部署。"><a href="#详解Hexo，快速上手，从使用到部署。" class="headerlink" title="详解Hexo，快速上手，从使用到部署。"></a>详解Hexo，快速上手，从使用到部署。</h3><hr><p>[TOC]</p><h3 id="第一步：准备基础工具"><a href="#第一步：准备基础工具" class="headerlink" title="第一步：准备基础工具"></a>第一步：准备基础工具</h3><ul><li>安装Git：<a href="https://gitforwindows.org/" target="_blank" rel="noopener">Download git</a></li><li>安装Node.js：<a href="https://nodejs.org/zh-cndownload/" target="_blank" rel="noopener">Download nodejs</a></li><li>安装Hexo：<a href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener">使用hexo</a><br><br>&emsp;&emsp;Hexo可以方便快捷的搭建起一个静态网站，这三个工具的安装已经非常成熟，如果遇到问题可以通过Google、百度解决</li></ul><h3 id="第二部：Hexo的基本使用"><a href="#第二部：Hexo的基本使用" class="headerlink" title="第二部：Hexo的基本使用"></a>第二部：Hexo的基本使用</h3><p>&emsp;&emsp;安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre><code>$ hexo init &lt;文件名&gt; $ cd &lt;文件名&gt; $ npm install 可能会遇到坑，每个人的环境都不一样，网上的解决方法很全。</code></pre><h3 id="第三步：新建完成后，指定文件夹的目录如下："><a href="#第三步：新建完成后，指定文件夹的目录如下：" class="headerlink" title="第三步：新建完成后，指定文件夹的目录如下："></a>第三步：新建完成后，指定文件夹的目录如下：</h3><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p><strong>_config.yml</strong>：<br>网站的 配置 信息，您可以在此配置大部分的参数。</p><p><strong>package.json</strong>：<br>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p><p><strong>scaffolds</strong>：<br>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><p><strong>source</strong>：<br>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p><p><strong>themes</strong>：<br>主题 文件夹。Hexo 会根据主题来生成静态页面。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过以上步骤就已经生成了静态网站，通过命令 hexo server 可以通过访问本地的链接进行查看。接下来可以通过 https://hexo.io/zh-cn/docs/commands 查看每个文件的具体信息。</span><br></pre></td></tr></table></figure><h3 id="第四步：更换主题"><a href="#第四步：更换主题" class="headerlink" title="第四步：更换主题"></a>第四步：更换主题</h3><p>&emsp;&emsp;上面的链接已经可以解决大部分的问题，接下来就是更换自己喜欢的主题，如果想要更换主题，需要参考<br><a href="https://segmentfault.com/a/1190000012805627" target="_blank" rel="noopener">如何更换主题</a>。 更换主题的时候有要注意，Hexo的主题模板可以到github搜索。例如：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a> 这种的路径</p><h3 id="第五步-为主题添加自己想要的按钮。"><a href="#第五步-为主题添加自己想要的按钮。" class="headerlink" title="第五步: 为主题添加自己想要的按钮。"></a>第五步: 为主题添加自己想要的按钮。</h3><p>​        更换了主题，发现新的主题没有归档、分类、标签、关于。想要添加这些可以通过 如下方法：<br>1：添加 关于页面<br>使用：hexo new page “about” 新建一个 关于页面。<br>主题的 _config.yml 文件中的 menu 中进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /      //主页</span><br><span class="line">categories: /categories //分类</span><br><span class="line">archives: /archives   //归档</span><br><span class="line">tags: /tags   //标签</span><br><span class="line">about: /about   //关于                  （添加此行即可）</span><br><span class="line">编辑 about 关于页面 md文件 重新hexo g &amp; hexo s 就能看到</span><br></pre></td></tr></table></figure><p>2：添加 标签页面<br>使用： hexo new page tags 新建一个 标签 页面。<br>主题的 _config.yml 文件中的 menu 中进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">home: /      //主页</span><br><span class="line">categories: /categories //分类</span><br><span class="line">archives: /archives   //归档</span><br><span class="line">tags: /tags   //标签                  （添加此行即可）</span><br><span class="line">about: /about   //关于</span><br><span class="line">底下的代码是在source/_post文件下的[文章名].md的最上面：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 标签测试</span><br><span class="line">tags:</span><br><span class="line">- Testing                   （这个就是文章的标签了）</span><br><span class="line">- Another Tag               （这个就是文章的标签了）</span><br></pre></td></tr></table></figure><p>3：添加 分类页面<br>使用： hexo new page categories 新建一个 分类 页面。<br>主题的 _config.yml 文件中的 menu 中进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">home: /      //主页</span><br><span class="line">categories: /categories //分类        （添加此行即可）</span><br><span class="line">archives: /archives   //归档</span><br><span class="line">tags: /tags   //标签                  </span><br><span class="line">about: /about   //关于</span><br><span class="line">底下的代码是在source/_post文件下的[文章名].md的最上面：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 分类测试</span><br><span class="line">categories:</span><br><span class="line">- hexo                       （这个就是文章的分类了）</span><br></pre></td></tr></table></figure><p>4：添加 归档页面<br>主题的 _config.yml 文件中的 menu 中进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /      //主页</span><br><span class="line">categories: /categories //分类        </span><br><span class="line">archives: /archives   //归档             （添加此行即可）</span><br><span class="line">tags: /tags   //标签                  </span><br><span class="line">about: /about   //关于</span><br></pre></td></tr></table></figure><p>5：添加 自定义页面<br>使用： hexo new page “guestbook” 新建一个 自定义 页面。<br>主题的 _config.yml 文件中的 menu 中进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /      //主页</span><br><span class="line">categories: /categories //分类        </span><br><span class="line">archives: /archives   //归档   </span><br><span class="line">tags: /tags   //标签                  </span><br><span class="line">about: /about   //关于</span><br><span class="line">guestbook: /guestbook    //自定义             （添加此行即可）</span><br></pre></td></tr></table></figure><p>添加了这些标签可以在主页面进行点击了，但是发现内容并不能显示，此时需要做如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以下代码在blog\source\categories\index.md文件</span><br><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2019-08-25 14:11:31</span><br><span class="line">layout: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>改完之后就OK了，注意：每个自己添加的按钮都需要添加（layout）。</p><h3 id="第六步-：做出了满意的博客，接下来就是让大家看到，这一步讲部署到github"><a href="#第六步-：做出了满意的博客，接下来就是让大家看到，这一步讲部署到github" class="headerlink" title="第六步 ：做出了满意的博客，接下来就是让大家看到，这一步讲部署到github"></a>第六步 ：做出了满意的博客，接下来就是让大家看到，这一步讲部署到github</h3><p>&emsp;&emsp;首先建个仓库，配置好自己的私钥，然后打开 Hexo 博客主配置文件 _config.yml，找到 deploy 属性，作如下配置：<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git  </span><br><span class="line">    repository:</span><br><span class="line">github: git@github.com:xxxx/xxxx.github.io.git</span><br><span class="line">coding: git@git.coding.net:xxxx/xxxx.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></p><p>执行命令：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br>可以参考github部署<a href="https://segmentfault.com/a/1190000018250408" target="_blank" rel="noopener">详细教程</a></p><h3 id="第八步：最后一步，绑定自己的域名。"><a href="#第八步：最后一步，绑定自己的域名。" class="headerlink" title="第八步：最后一步，绑定自己的域名。"></a>第八步：最后一步，绑定自己的域名。</h3><p>直接跟着这个链接配置即可。<a href="https://blog.csdn.net/Wonz5130/article/details/82828761" target="_blank" rel="noopener">https://blog.csdn.net/Wonz5130/article/details/82828761</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;详解Hexo，快速上手，从使用到部署。&quot;&gt;&lt;a href=&quot;#详解Hexo，快速上手，从使用到部署。&quot; class=&quot;headerlink&quot; title=&quot;详解Hexo，快速上手，从使用到部署。&quot;&gt;&lt;/a&gt;详解Hexo，快速上手，从使用到部署。&lt;/h3&gt;&lt;hr&gt;

      
    
    </summary>
    
      <category term="其他" scheme="https://Daong.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="博客" scheme="https://Daong.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
