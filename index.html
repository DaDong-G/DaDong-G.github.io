<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="大东的博客" type="application/atom+xml">






<meta name="description" content="技术、python、go、运维">
<meta property="og:type" content="website">
<meta property="og:title" content="大东的博客">
<meta property="og:url" content="https://Daong.com/index.html">
<meta property="og:site_name" content="大东的博客">
<meta property="og:description" content="技术、python、go、运维">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大东的博客">
<meta name="twitter:description" content="技术、python、go、运维">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://Daong.com/">





  <title>大东的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大东的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">东子的技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Daong.com/2019/12/20/Rpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="东子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/20/Rpc/" itemprop="url">Go语言练习Rpc</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-20T10:09:00+08:00">
                2019-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go语言/" itemprop="url" rel="index">
                    <span itemprop="name">Go语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Rpc架构"><a href="#Rpc架构" class="headerlink" title="Rpc架构"></a>Rpc架构</h2><p><img src="/2019/12/20/Rpc/rpc.jpg" alt="rpc图片"></p>
<p>Rpc就是从一台机器（客户端）上通过传递参数的方法远程调用另一台机器（或者另一个进程）的函数或者方法，统称服务，并且返回结果。</p>
<p>Rpc的流程如上图：</p>
<ol>
<li><p>调用者（Caller, 也叫客户端、Client）以本地调用的方式发起调用；</p>
</li>
<li><p>Client stub（客户端存根，可理解为辅助助手）收到调用后，负责将被调用的方法名、参数等打包编码成特定格式的能进行网络传输的消息体；</p>
</li>
<li><p>Client stub将消息体通过网络发送给对端（服务端）</p>
</li>
<li><p>Server stub（服务端存根，同样可理解为辅助助手）收到通过网络接收到消息后按照相应格式进行拆包解码，获取方法名和参数；</p>
</li>
<li><p>Server stub根据方法名和参数进行本地调用；</p>
</li>
<li><p>被调用者（Callee，也叫Server）本地调用执行后将结果返回给server stub;</p>
</li>
<li><p>Server stub将返回值打包编码成消息，并通过网络发送给对端（客户端）；</p>
</li>
<li><p>Client stub收到消息后，进行拆包解码，返回给Client；</p>
</li>
<li><p>Client得到本次RPC调用的最终结果。</p>
<p><strong>RPC的目标就是要2~8这些步骤都封装起来，让使用者对这些细节透明。</strong></p>
</li>
</ol>
<p>首先实现一个最简单的Rpc，将Go语言中有标准包net/rpc，下面代码中没有设计client stub sever sub  以及网络通信的详细描述，RPC也希望屏蔽这些信息，开发人员只需要调用。</p>
<p>Server 端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//定义一个方法，必须满足RPC规则，方法只能有两个可序列化的参数,第二个参数是指针类型。</span><br><span class="line">func (h *HelloServer)Hello(request int,reply *string)error&#123;</span><br><span class="line">	*reply = fmt.Sprintf(&quot;Hello 方法: %d&quot;,request)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">		// RegisterName 将对象类型中，所有满足RPC规则的方法进行注册。放在HelloServer下。</span><br><span class="line">		err := rpc.RegisterName(&quot;HelloServer&quot;, new(HelloServer))</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			//fmt.Println(err)</span><br><span class="line">			log.Fatal(&quot;Rpc名称注册错误&quot;)</span><br><span class="line">			//fmt.Println(&quot;Rpc名称注册错误&quot;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		listener, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:1234&quot;)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatal(&quot;accept error;接收错误&quot;)</span><br><span class="line">			//fmt.Println(&quot;Rpc名称注册错误&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	for &#123;</span><br><span class="line">		fmt.Println(&quot;开始循环接收请求&quot;)</span><br><span class="line">		conn, err := listener.Accept()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;		</span><br><span class="line">		rpc.ServeConn(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cilent 端 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func main()  &#123;</span><br><span class="line">	// 拨号 输入协议名称，地址</span><br><span class="line">	client,err := rpc.Dial(&quot;tcp&quot;,&quot;127.0.0.1:1234&quot;)</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	var replay * string</span><br><span class="line">	var replayGoodMethods * string</span><br><span class="line">	// 定义的replay 用于接收服务端处理完的请求。Call方法用于发送请求，是同步的。</span><br><span class="line">	// client.Go可以异步的发送请求。</span><br><span class="line">	err = client.Call(&quot;HelloServer.Hello&quot;,123,&amp;replay)</span><br><span class="line">	err = client.Call(&quot;HelloServer.Good&quot;,&quot;Client 端Good方法&quot;,&amp;replayGoodMethods)</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">		fmt.Println(&quot;Send remote method error&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;%#v\n&quot;, *replay)</span><br><span class="line">	fmt.Printf(&quot;%#v\n&quot;, *replayGoodMethods)</span><br><span class="line">	err = client.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基础的Client 与Server已经完成，在RPC开发中开发人员一般有三种角色，服务器RPC方法的开发人员，客户端调用RPC的人员，指定RPC客户端与服务器协议的人员。</p>
<p>接下来讲HelloServer服务进行重构，进行接口封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const HelloServerName  = &quot;HelloService&quot;</span><br><span class="line"></span><br><span class="line">// 定义封装一个接口</span><br><span class="line">type HelloServerInterface interface &#123;</span><br><span class="line">	Hello(request int, reply *string) error</span><br><span class="line">	Good(request string, reply *string) error</span><br><span class="line">&#125;</span><br><span class="line">// 定义一个类</span><br><span class="line">type struct HelloService&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 接口方法</span><br><span class="line">func RegisterHelloService(svc HelloServerInterface)&#123;</span><br><span class="line">	return rpc.RegisterName(HelloServerName,svc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//必须满足RPC规则，方法只能有两个可序列化的参数,第二个参数是指针类型。</span><br><span class="line">func (h *HelloServer)Hello(request int,reply *string)error&#123;</span><br><span class="line">	*reply = fmt.Sprintf(&quot;Hello 方法: %d&quot;,request)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *HelloServer)Good(request string,reply *string)error&#123;</span><br><span class="line">	*reply = &quot;Good 方法:&quot; + request</span><br><span class="line">	return nil</span><br></pre></td></tr></table></figure>

<p>可以对Client端也进行一次封装,这样可以避免出现参数类型不匹配等低级错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const HelloServerName  = &quot;HelloService&quot;</span><br><span class="line">type HelloServerClient struct &#123;</span><br><span class="line">	Client *rpc.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DialHelloService(network,address string)(*HelloServerClient,error)&#123;</span><br><span class="line">	c , err := rpc.Dial(network,address)</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		return nil,err</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;HelloServerClient&#123;Client:c&#125;,nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p HelloServerClient)Hello(request int,reply *string)error&#123;</span><br><span class="line">	return p.Client.Call(HelloServerName+&quot;.Hello&quot;, request, reply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p HelloServerClient)Good(request string,reply *string)error&#123;</span><br><span class="line">	return p.Client.Call(HelloServerName+&quot;.Good&quot;, request, reply)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">	client , err := DialHelloService(&quot;tcp&quot;,&quot;127.0.0.1:1234&quot;)</span><br><span class="line">	//client,err := rpc.Dial(&quot;tcp&quot;,&quot;127.0.0.1:1234&quot;)封装在DialHelloService方法</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	var replay string</span><br><span class="line">	var replayGoodMethods string</span><br><span class="line">	err = (*client).Hello(1213, &amp;replay)</span><br><span class="line">	err = (*client).Good(&quot;Good方法&quot;,&amp;replayGoodMethods)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;%#v\n&quot;, replay)</span><br><span class="line">	fmt.Printf(&quot;%#v,\n&quot;, replayGoodMethods)</span><br><span class="line">	_ = client.Client.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Daong.com/2019/11/28/Context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="东子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/28/Context/" itemprop="url">Go语言通过Context控制goroutine的退出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-28T10:09:00+08:00">
                2019-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go语言/" itemprop="url" rel="index">
                    <span itemprop="name">Go语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Go-通过-Context控制goroutine-的退出"><a href="#Go-通过-Context控制goroutine-的退出" class="headerlink" title="Go 通过 Context控制goroutine 的退出"></a>Go 通过 Context控制goroutine 的退出</h2><p>下面的程序会无线循环，直到4秒后，主进程退出。那么如何优雅的控制子goroutine退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func f ()&#123;</span><br><span class="line">	go g()</span><br><span class="line">	time.Sleep(time.Second * 4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func g ()&#123;</span><br><span class="line">	for  &#123;</span><br><span class="line">		fmt.Println(&quot;急啊急啊急啊&quot;)</span><br><span class="line">		time.Sleep(time.Second * 2)</span><br><span class="line">	&#125;</span><br><span class="line">	//如何通知子goroutine退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用chan进行改进，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">var ch = make(chan bool)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func f ()&#123;</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	go g()</span><br><span class="line">	time.Sleep(time.Second * 2)</span><br><span class="line">	ch &lt;- true</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func g ()&#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">LOOP:</span><br><span class="line">	for  &#123;</span><br><span class="line">		fmt.Println(&quot;急啊急啊急啊&quot;)</span><br><span class="line">		time.Sleep(time.Second * 2)</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;- ch: //当接收到一个chan跳出for循环，</span><br><span class="line">			break LOOP</span><br><span class="line">		default:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//如何通知子goroutine退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Context版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func f ()&#123;</span><br><span class="line">	// 开启一个context,context.Background()为父节点。</span><br><span class="line">	// ctx 是个接口，ctx,Done()会返回一个chanel</span><br><span class="line">	// cancel是一个函数类型 用于关闭</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	go g(ctx)</span><br><span class="line">	time.Sleep(time.Second * 4)</span><br><span class="line">	//ch &lt;- true</span><br><span class="line">	cancel()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func g (ctx context.Context)&#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">LOOP:</span><br><span class="line">	for  &#123;</span><br><span class="line">		fmt.Println(&quot;等待退出&quot;)</span><br><span class="line">		time.Sleep(time.Second * 2)</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;- ctx.Done(): //ctx.Done() 会返回一个chanel</span><br><span class="line">			break LOOP</span><br><span class="line">		default:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//如何通知子goroutine退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context.Context</code>是一个接口，该接口定义了四个需要实现的方法。具体签名如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Deadline 设置具体时间结束子进程</p>
<p>Done  当决定子线程结束时，context.Done()可以得到一个空的chan</p>
<p>Err  返回错误</p>
<p>Value 方法会从<code>Context</code>中返回键对应的值，对于同一个上下文来说，多次调用<code>Value</code> 并传入相同的<code>Key</code>会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据；</p>
<h4 id="一般以context-Background-实现一个跟节点，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。"><a href="#一般以context-Background-实现一个跟节点，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。" class="headerlink" title="一般以context.Background()实现一个跟节点，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。"></a>一般以context.Background()实现一个跟节点，那么是如何衍生更多的子Context的呢？这就要靠context包为我们提供的With系列的函数了。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 返回的cancel 方法可以用于结束子goroutine，子goroutine中的context.DOne()会接收一个chan struct&#123;&#125;。</span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line"></span><br><span class="line">// 定一个具体时间，结束子goroutine，也可以手动结束，官方建议所有的最好手动关闭。</span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) </span><br><span class="line"></span><br><span class="line">// 定多少事件后，结束子goroutine，也可以手动结束，官方建议所有的最好手动关闭。</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) </span><br><span class="line"></span><br><span class="line">// 用于传递一个值给子goroutine</span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Daong.com/2019/11/11/Go_Work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="东子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/11/Go_Work/" itemprop="url">Go语言中无缓冲通道实现并发池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-11T10:09:00+08:00">
                2019-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go语言/" itemprop="url" rel="index">
                    <span itemprop="name">Go语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Go-语言并发，使用无缓冲通道构建并发池。"><a href="#Go-语言并发，使用无缓冲通道构建并发池。" class="headerlink" title="Go 语言并发，使用无缓冲通道构建并发池。"></a>Go 语言并发，使用无缓冲通道构建并发池。</h2><p>首先构建一个并发池，有两个字段一个是work  通道类型，一个是sync.WaitGroup。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Pool struct &#123;   </span><br><span class="line">	work chan Worker   </span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为工作并发池 提供一个接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Worker interface &#123;</span><br><span class="line">	Task()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着创建一个新的工作池，使用工厂函数来创建,返回值为Pool</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func New(maxGoroutines int) *Pool  &#123;</span><br><span class="line">	p := Pool&#123;</span><br><span class="line">		work : make(chan Worker),</span><br><span class="line">	&#125;</span><br><span class="line">	p.wg.Add(maxGorotuine) //往并发池添加并发的数量</span><br><span class="line">	for i:= 0 ; i &lt; maxGoroutines; i ++&#123;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for w := range p.work&#123;   // 这里会发生阻塞，在创建的时候，异步阻塞，返回一个池</span><br><span class="line">				w.Task()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		p.wg.Done()</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;p</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将工作提交到工作池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (p *Pool)Run(w Worker)  &#123;</span><br><span class="line">	p.work &lt;- w</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭工作池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func (p *Pool)Shutdown()&#123;   </span><br><span class="line">	close(p.work)   </span><br><span class="line">	p.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是对上面的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var names = []string&#123;</span><br><span class="line">	&quot;steve&quot;,</span><br><span class="line">	&quot;bob&quot;,</span><br><span class="line">	&quot;mary&quot;,</span><br><span class="line">	&quot;therese&quot;,</span><br><span class="line">	&quot;jason&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type namePrinter struct &#123;</span><br><span class="line">	name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *namePrinter)Task()  &#123;</span><br><span class="line">	fmt.Println(m.name)</span><br><span class="line">	time.Sleep(time.Second )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">	p := New(10) //创建10个并发池子</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	wg.Add(10 * len(names))</span><br><span class="line"></span><br><span class="line">	// time.Sleep(3 * time.Second)</span><br><span class="line"></span><br><span class="line">	for i :=0 ; i &lt; 10 ; i ++&#123;</span><br><span class="line">		for _ , name := range names&#123;</span><br><span class="line">			np := namePrinter&#123;</span><br><span class="line">				name : name,</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			go func() &#123;</span><br><span class="line">				p.Run(&amp;np)</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	p.Shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Daong.com/2019/10/15/Go日志定制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="东子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/15/Go日志定制/" itemprop="url">Go语言中基本的日志格式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-15T10:09:00+08:00">
                2019-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go语言/" itemprop="url" rel="index">
                    <span itemprop="name">Go语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Go语言日志的基本格式"><a href="#Go语言日志的基本格式" class="headerlink" title="Go语言日志的基本格式"></a>Go语言日志的基本格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">	&quot;io/ioutil&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">	Trace.Println(&quot;这是Trac&quot;)</span><br><span class="line">	Info.Println(&quot;这是Info&quot;)</span><br><span class="line">	Warning.Println(&quot;这是Warning&quot;)</span><br><span class="line">	Error.Println(&quot;这是Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	Trace 			*log.Logger // 记录所有的日志</span><br><span class="line">	Info  			*log.Logger // 记录重要的信息</span><br><span class="line">	Warning 		*log.Logger // 需要注意的信息</span><br><span class="line">	Error    		*log.Logger // 记录非常严重信息</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">	file,err := os.OpenFile(&quot;./errors.txt&quot;,os.O_CREATE,0666)</span><br><span class="line">	if err!= nil&#123;</span><br><span class="line">		log.Fatalln(&quot;Failed to open error log&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	Trace = log.New(ioutil.Discard,&quot;Trace:&quot;,log.Ldate | log.Ltime | log.Lshortfile)  //ioutil.Discard 不输出，不写入，可以用于占位</span><br><span class="line">	Info = log.New(os.Stdout,&quot;Info:&quot;,log.Ldate | log.Ltime | log.Lshortfile) //os.Stdout  不记录日志仅仅作为标准输出</span><br><span class="line">	Warning = log.New(file,&quot;Warning:&quot;,log.Ldate | log.Ltime | log.Lshortfile) // file  会将日志写入file,并输出</span><br><span class="line">	Error = log.New(io.MultiWriter(file,os.Stdin),&quot;Error:&quot;,log.Ldate | log.Ltime | log.Lshortfile) //写入，不输出，可以更改os.std。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Daong.com/2019/09/21/Mysql_optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="东子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/21/Mysql_optimization/" itemprop="url">Mysql数据库查询优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-21T10:09:40+08:00">
                2019-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="如何获得有性能问题的sql"><a href="#如何获得有性能问题的sql" class="headerlink" title="如何获得有性能问题的sql"></a>如何获得有性能问题的sql</h3><p><strong>慢查询日志：</strong></p>
<p>​    MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10S以上的语句。默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p>
<p><strong>MySQL 慢查询的相关参数解释：</strong></p>
<p>slow_query_log    ：是否开启慢查询日志，1表示开启，0表示关闭。<br>log-slow-queries  ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log<br>long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。<br>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。<br>log_output：日志存储方式。log_output=’FILE’表示将日志存入文件，默认值是’FILE’。log_output=’TABLE’表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=’FILE,TABLE’。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</p>
<p><strong>慢查询日志配置</strong></p>
<p>​        默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables  like &apos;%slow_query_log%&apos;;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                           |</span><br><span class="line">| slow_query_log_file | /home/WDPM/MysqlData/mysql/DB-Server-slow.log |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; set global slow_query_log=1;</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; show variables like &apos;%slow_query_log%&apos;;</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                         |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">| slow_query_log      | ON                                            |</span><br><span class="line">| slow_query_log_file | /home/WDPM/MysqlData/mysql/DB-Server-slow.log |</span><br><span class="line">+---------------------+-----------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p><strong>慢查询日志相关分析工具mysqldumpslow</strong><br>​        -s, 是表示按照何种方式排序，</p>
<blockquote>
<p>c: 访问计数</p>
<p>l: 锁定时间</p>
<p>r: 返回记录</p>
<p>t: 查询时间</p>
<p>al:平均锁定时间</p>
<p>ar:平均返回记录数</p>
<p>at:平均查询时间</p>
</blockquote>
<p>-t, 是top n的意思，即为返回前面多少条的数据；<br>-g, 后边可以写一个正则匹配模式，大小写不敏感的；<br>比如<br>得到返回记录集最多的10个SQL。<br>mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log<br>得到访问次数最多的10个SQL<br>mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log<br>得到按照时间排序的前10条里面含有左连接的查询语句。<br>mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log<br>另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。<br>mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more<br>实时获取有问题的sql</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Daong.com/2019/09/14/Mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="东子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/14/Mysql/" itemprop="url">Mysql数据库的事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-14T10:09:40+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Mysql事务四个特性"><a href="#Mysql事务四个特性" class="headerlink" title="Mysql事务四个特性"></a>Mysql事务四个特性</h3><ul>
<li>一致性</li>
<li>原子性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<h4 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h4><p>整个事务中所有的操作要么全部提交成功，要么全部失败回滚。</p>
<h4 id="一致性："><a href="#一致性：" class="headerlink" title="一致性："></a>一致性：</h4><p>数据库中的数据从一种状态转到另外一种状态，数据的完整性没有被破坏。</p>
<h4 id="隔离性："><a href="#隔离性：" class="headerlink" title="隔离性："></a>隔离性：</h4><ol>
<li><p>未提交读(Read-uncommited)：<br>(begin)开启一个事务(A)，对数据进行了更改，并未commit。此时另外一个事务(B)，可以读取到事务A 修改的数据。所以，如果事务A突然崩溃回滚，那么事务(B)读取的数据是不正确的。 未提交读也称为脏读。</p>
</li>
<li><p>读取-已提交(Read-committed):<br>例1： (begin)开启一个事务(A),对数据(money:200 )进行了修改(money:2000)，并未commit，此时另外一个事务(B)无法读取到修改后的数据，如果此时B也对数据进行修改(money:200)修改为(money:2000) UPDATE test_shiwu SET money = 300 WHERE money = 2000;, 那么将会阻塞，直到事务A commit 才能解除阻塞，解除后无法修改，因为无法找money = 2000的数据，此时money已经被A修改成了200。<br>例2：(begin)开启一个事务(A), (begin)开启一个事务(B),A事务修改了数据，并且进行了提交，此时B事务对数据进行查询，可以读取到A修改后的数据。</p>
</li>
<li><p>可重复读取(RepeaTable-Read):<br>(begin)开启一个事务(A), (begin)开启一个事务(B),A事务修改了数据，并且进行了提交，此时B事务对数据进行查询，查到的数据依然是修改前的数据，只有B事务commit后，才能读取到A修改后的数据。</p>
</li>
<li><p>串行化(serializable):</p>
<p> (begin)开启一个事务(A), (begin)开启一个事务(B)，由于A事务先开启，所以此时B操作数据库任何信息都会发生阻塞，直到A commit 才能解除阻塞。    </p>
</li>
</ol>
<h4 id="持久性："><a href="#持久性：" class="headerlink" title="持久性："></a>持久性：</h4><p>事务一旦提交，其更改是永久性的，即使数据库系统崩溃也能恢复。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Daong.com/2019/09/14/docker_compose/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="东子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/14/docker_compose/" itemprop="url">Docker之Docker-compose</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-14T10:09:00+08:00">
                2019-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/虚拟化/" itemprop="url" rel="index">
                    <span itemprop="name">虚拟化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是Docker-compose"><a href="#什么是Docker-compose" class="headerlink" title="什么是Docker-compose"></a>什么是Docker-compose</h3><p>docker-compose技术，就是通过一个 <strong>.yml</strong> 配置文件，将所有的容器的部署方法、文件映射、容器连接等等一系列的配置写在一个配置文件里，最后只需要执行docker-compose up命令就会像执行脚本一样的去一个个安装容器并自动部署他们，极大的便利了复杂服务的部署。</p>
<h3 id="Docker-compose-撰写案例"><a href="#Docker-compose-撰写案例" class="headerlink" title="Docker-compose 撰写案例"></a>Docker-compose 撰写案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.6&quot;   # 代表语言版本</span><br><span class="line">services: # 代表要启动哪几个容器</span><br><span class="line">  flask-web: # 自己起一个名字</span><br><span class="line">    build: .  # 如果使用dockerfile就是用build .,如果是已经有的镜像，使用用images</span><br><span class="line">    ports: # 需要映射的端口 很多种写法，可以查</span><br><span class="line">      - &quot;5000:5000&quot;</span><br><span class="line">    container_name: flask-web # 容器起个名字</span><br><span class="line">    networks: # 使用的网络</span><br><span class="line">      - web</span><br><span class="line">  redis: #  容器项目 名字</span><br><span class="line">    image: redis  # 使用的镜像 redis </span><br><span class="line">    container_name: redis # 容器名称</span><br><span class="line">    networks:</span><br><span class="line">      - web</span><br><span class="line">    volumes: # 容器挂载的地址，遵循下面的volumes写，可以保证即便删除，下次数据不会丢失，都存在了数据卷里面。  </span><br><span class="line">      - redis-dat:/data # 将数据卷挂载到容器/data 文件  </span><br><span class="line">networks: # 定义网络类型</span><br><span class="line">  web:</span><br><span class="line">    driver: &quot;bridge&quot;  # 设置网络类型</span><br><span class="line">volumes: # 容器挂载地址</span><br><span class="line">  redis-dat:  # 代表的是 name</span><br><span class="line">    driver: &quot;local&quot;    # 代表的是DRIVERname</span><br></pre></td></tr></table></figure>

<h3 id="Docker-compose-命令"><a href="#Docker-compose-命令" class="headerlink" title="Docker-compose 命令"></a>Docker-compose 命令</h3><p>docker-compose up：该命令可以自动完成包括构建镜像，(重新)创建服务，启动服务，并关联服务相关容器的一系列操作。 -d 代表后台运行</p>
<p>docker-compose pause ：暂停服务<br>docker-compose unpause  ：恢复被暂停的服务</p>
<p>dokcer-compose ps ： 此命令与docker ps不同作用，此命令会显示停止后的容器（状态为Exited），只针对某个项目。</p>
<p>docker-compose restart [service_name]：重启某个项目，只有正在运行的服务可以使用重启命令，停止的服务是不可以重启</p>
<p>docker-compose start : 启动运行某个服务的所有容器<br>docker-compose stop : 停止运行某个服务的所有容器</p>
<p>docker-compose logs [service_name] : 显示service的日志信息</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Daong.com/2019/09/11/DockerFile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="东子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/11/DockerFile/" itemprop="url">Docker之Dockerfile</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-11T10:09:00+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/虚拟化/" itemprop="url" rel="index">
                    <span itemprop="name">虚拟化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是Dockerfile："><a href="#什么是Dockerfile：" class="headerlink" title="什么是Dockerfile："></a>什么是Dockerfile：</h3><p>Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取<code>Dockerfile</code>中的指令自动生成映像。</p>
<p><code>docker build</code>命令用于从Dockerfile构建映像。可以在<code>docker build</code>命令中使用<code>-f</code>标志指向文件系统中任何位置的Dockerfile。</p>
<h3 id="Dockerfile的撰写示例"><a href="#Dockerfile的撰写示例" class="headerlink" title="Dockerfile的撰写示例"></a>Dockerfile的撰写示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 搭建一个基于flask 的web项目</span><br><span class="line">FROM python:3.6-alpine</span><br><span class="line">LABEL Description=&quot;本镜像用于启动建议的基于flask的web程序&quot; Author=&quot;Itcast&quot; Version=&quot;1.0&quot;</span><br><span class="line"># 将代码保存到镜像</span><br><span class="line">COPY ./code /flask-code</span><br><span class="line"># 运行目录至code 目录下</span><br><span class="line">WORKDIR /flask-code</span><br><span class="line"># 执行 安装 项目需要的依赖</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line"># 执行代码</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>

<p>docker build /home/dockerfile-dir/ -t test-image:v1.0     -t的代表命名  </p>
<p>执行上述命令，会执行/home/dockerfile-dir/  下面的Dockerfile文件</p>
<h3 id="Dockerfile文档中的命令："><a href="#Dockerfile文档中的命令：" class="headerlink" title="Dockerfile文档中的命令："></a>Dockerfile文档中的命令：</h3><ol>
<li><p>FROM   //指定基于哪个基础镜像格式 FROM <p_w_picpath> 或者  FROM <p_w_picpath>:<tag>，  比如</tag></p_w_picpath></p_w_picpath></p>
<p>FROM centos</p>
<p>FROM centos:latest</p>
</li>
</ol>
<ol start="2">
<li><p>MAINTAINER  //指定作者信息</p>
<p>格式  MAINTAIN <name> ，比如</name></p>
<p>MAINTAINER  aming  <a href="mailto:aming@aminglinux.com" target="_blank" rel="noopener">aming@aminglinux.com</a></p>
</li>
</ol>
<ol start="3">
<li><p>RUN   //镜像操作指令</p>
<p>格式为 RUN <command>  或者 RUN [“executable”, “param1”, “param2”]，比如</p>
<p>RUN  yum install  httpdRUN [“/bin/bash”, “-c”, “echo hello”]</p>
</li>
</ol>
<ol start="4">
<li><p>CMD  // 三种格式：CMD [“executable”, “param1”, “param2”]CMD command param1 param2</p>
<p>CMD [“param1”, “param2”]</p>
<p>RUN和CMD看起来挺像，但是CMD用来指定容器启动时用到的命令，只能有一条。比如</p>
<p>CMD [“/bin/bash”, “/usr/local/nginx/sbin/nginx”, “-c”, “/usr/local/nginx/conf/nginx.conf”]</p>
</li>
</ol>
<ol start="5">
<li><p>EXPOSE  格式为 EXPOSE <port> [<port>…] , 比如</port></port></p>
<p>EXPOSE 22 80 8443这个用来指定要映射出去的端口，比如容器内部我们启动了sshd和nginx，所以我们需要把22和80端口暴漏出去。这个需要配合-P（大写）来工作，也就是说在启动容器时，需要加上-P，让它自动分配。如果想指定具体的端口，也可以使用-p（小写）来指定。</p>
</li>
</ol>
<ol start="6">
<li><p>ENV  格式 ENV  <key> <value>, 比如  </value></key></p>
<p>ENV PATH /usr/local/mysql/bin:$PATH它主要是为后续的RUN指令提供一个环境变量，我们也可以定义一些自定义的变量</p>
<p>ENV MYSQL_version 5.6</p>
</li>
</ol>
<ol start="7">
<li><p>ADD  </p>
<p>格式 add <src> <dest></dest></src></p>
<p>将本地的一个文件或目录拷贝到容器的某个目录里。 其中src为Dockerfile所在目录的相对路径，它也可以是一个url。比如</p>
<p>ADD &lt;conf/vhosts&gt; &lt;/usr/local/nginx/conf&gt;</p>
</li>
</ol>
<ol start="8">
<li><p>COPY  格式同add</p>
<p>使用方法和add一样，不同的是，它不支持url</p>
</li>
</ol>
<ol start="9">
<li><p>ENTRYPOINT  </p>
<p>格式类似CMD</p>
<p>容器启动时要执行的命令，它和CMD很像，也是只有一条生效，如果写多个只有最后一条有效。和CMD不同是：CMD 是可以被 docker run 指令覆盖的，而ENTRYPOINT不能覆盖。比如，容器名字为aming</p>
<p>我们在Dockerfile中指定如下CMD：</p>
<p>CMD [“/bin/echo”, “test ”]</p>
<p>启动容器的命令是  docker run aming 这样会输出 test</p>
<p>假如启动容器的命令是 docker run -it aming  /bin/bash  什么都不会输出</p>
<p>ENTRYPOINT不会被覆盖，而且会比CMD或者docker run指定的命令要靠前执行</p>
<p>ENTRYPOINT [“echo”, “test”]</p>
<p>docker run -it aming  123</p>
<p>则会输入 test  123 ，这相当于要执行命令  echo test  123 </p>
</li>
</ol>
<ol start="10">
<li><p>VOLUME </p>
<p>格式  VOLUME [“/data”]</p>
<p>创建一个可以从本地主机或其他容器挂载的挂载点。</p>
</li>
</ol>
<ol start="11">
<li><p>USER  </p>
<p>格式 USER daemon</p>
<p>指定运行容器的用户</p>
</li>
</ol>
<ol start="12">
<li><p>WORKDIR  </p>
<p>格式 WORKDIR  /path/to/workdir</p>
<p>为后续的RUN、CMD或者ENTRYPOINT指定工作目录</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Daong.com/2019/09/08/Docker_data_volume/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="东子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/08/Docker_data_volume/" itemprop="url">Docker基础之数据卷</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-08T10:09:00+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/虚拟化/" itemprop="url" rel="index">
                    <span itemprop="name">虚拟化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据卷挂载的三种方式"><a href="#数据卷挂载的三种方式" class="headerlink" title="数据卷挂载的三种方式"></a>数据卷挂载的三种方式</h3><ul>
<li>bind mounts：将宿主机上的一个文件或目录被挂载到容器上。</li>
<li>volumes: 由docker创建和管理，使用docker volume 命令管理，相当于是对bind mounts 的封装。</li>
<li>tmpfs mounts: 一种基于内存的的临时文件系统，该方法不会将数据写入磁盘，写在内存中。</li>
</ul>
<h3 id="volume-相关命令："><a href="#volume-相关命令：" class="headerlink" title="volume 相关命令："></a>volume 相关命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker volume create [name] 创建数据卷</span><br><span class="line"></span><br><span class="line">docker volume inspect [name] 查看数据卷详情</span><br><span class="line"></span><br><span class="line">docker volume prune 删除未使用的数据卷</span><br><span class="line"></span><br><span class="line">docker volume ls 查看所有数据卷</span><br><span class="line"></span><br><span class="line">docker rm volume</span><br></pre></td></tr></table></figure>

<h3 id="bind-mounts："><a href="#bind-mounts：" class="headerlink" title="bind mounts："></a>bind mounts：</h3><ol>
<li><p>方法一： -v 参数，跟文件路径</p>
<p>​    docker run -dit  -v /volume:/data –name centos_test centos </p>
<p>​    将/volume 挂载到 容器 /data ,如果本地的文件不存在，会自动创建</p>
</li>
<li><p>方法二：–mount type=bind,src=本地路径,dst=容器路径  centos </p>
<p>​    docker run -dit –mount type=bind,src=/volume,dst=/root/v –name centos_test centos</p>
<p>​    将/volume 挂载到 容器 /root/v,如果本地的文件不存在，报错</p>
</li>
</ol>
<h3 id="volumes："><a href="#volumes：" class="headerlink" title="volumes："></a>volumes：</h3><ol>
<li><p>方法一： -v 参数  跟数据卷的名称</p>
<p>​    docker run -dit -v volume-test:/root/a centos</p>
<p>​    docker 会创建出来一个volume数据卷挂载到容器的 root/a路径</p>
</li>
<li><p>方法二：–mount type=volume,src=本地路径,dst=容器路径  centos </p>
<p>​    docker run -dit –mount type=volume,src=volume-test(数据卷名称),dst=/root/v   centos</p>
<p>​    文件不存在不会报错，都会自动创建</p>
</li>
</ol>
<h3 id="tmpfs-："><a href="#tmpfs-：" class="headerlink" title="tmpfs ："></a>tmpfs ：</h3><p>​        –mount type=tmpfs,dst=容器路径  centos。只有一种方法</p>
<h3 id="共享其他容器的数据卷："><a href="#共享其他容器的数据卷：" class="headerlink" title="共享其他容器的数据卷："></a>共享其他容器的数据卷：</h3><p>​            docker run -dti –volumes-from 容器名  镜像名 </p>
<h3 id="数据卷使用注意："><a href="#数据卷使用注意：" class="headerlink" title="数据卷使用注意："></a>数据卷使用注意：</h3><p>​            <strong>如果挂载一个空的数据卷到容器中的一个非空目录中，那么这个目录下的文件会被复制到数据卷中。<br>​            如果挂载一个非空的数据卷到容器中的一个目录中，那么容器中的目录中会显示数据卷中的数据。如果原            来容器中的目录中有数据，那么这些原始数据会被隐藏掉。</strong></p>
<p>​    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Daong.com/2019/09/07/Docker_network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="东子">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大东的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/Docker_network/" itemprop="url">Docker基础之网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-07T14:40:40+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/虚拟化/" itemprop="url" rel="index">
                    <span itemprop="name">虚拟化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><p>容器的网络默认与宿主机，其他容器都是相互隔离的。</p>
<p><strong>查看docker已经创建的网络对象</strong>： docker network ls </p>
<p><strong>查看网络详情</strong>：docker network inspect 网络名/id</p>
<p><strong>创建网络</strong>：docker create -d bridge  name  -d 默认为bridge 。注意：host 网络与 null 网络只能存在一个。 </p>
<p><strong>删除网络</strong>：docker network rm 网络名/id</p>
<p><strong>使用网络</strong>：docker run  –network host -dti –name 容器名 镜像名</p>
<p><strong>Docker网络类型</strong>：</p>
<ol>
<li><p>bridage</p>
<ol>
<li><p>宿主机需要有单独的bridage网卡，如docker 默认创建的docker0</p>
</li>
<li><p>外部无法直接访问容器，需要建立端口映射</p>
</li>
<li><p>每创建一个bridage网络，都会自动在宿主机上创建一个veth的网络。</p>
</li>
<li><p>每一个容器都有单独的ip。</p>
</li>
<li><p>容器直接无法直接通信，需要借助veth –&gt; docker0 这样进行通信。</p>
</li>
<li><p>宿主机上的veth 与 docker容器里面的 etho 是网络设备对。</p>
</li>
<li><p>bridage 网络的端口映射,将宿主机上面的某一端口，映射到容器的某一个端口。</p>
</li>
</ol>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将镜像中暴漏出来的端口，全部随机映射到宿主机:</span><br><span class="line">docker run -dti --name test_redis -P redis </span><br><span class="line">0.0.0.0:32768-&gt;6379/tcp</span><br><span class="line">镜像只有暴露了端口，才能使用。</span><br></pre></td></tr></table></figure>

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -dti --name test_redis -p 127.0.0.1:8000:6379 redis(本地ip 127.0.0.1,8000端口，映射到容器的6379端口)</span><br><span class="line">docker run -dti --name test_redis -p :8000:6379 redis  (本地8000端口映射，任意ip访问)</span><br><span class="line">docker run -dti --name test_redis -p ::6379 redis  (本地随机端口映射，任意ip访问)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Host网络</p>
<ol>
<li>容器完全共享宿主机的网络，没有任何网络隔离，宿主机的网络就是容器的网络</li>
<li>容器、宿主机上所有的端口不能重复，即端口必须唯一</li>
<li>外部可以直接访问容器，无需端口映射</li>
<li>容器的ip就是宿主机的ip   </li>
</ol>
</li>
<li><p>none 网络  </p>
<ol>
<li>容器上没有网络，也没有任何网络设备</li>
<li>如果需要网络，需要用户自行安装与配置</li>
<li>该模式适合需要高度制定网络的用户使用</li>
</ol>
</li>
<li><p>Overlay 网络</p>
<ol>
<li>也称覆盖网络，主要用于实现跨主机容器间的通讯。</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">东子</p>
              <p class="site-description motion-element" itemprop="description">技术、python、go、运维</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">东子</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
